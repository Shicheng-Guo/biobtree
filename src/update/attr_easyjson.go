// Code generated by easyjson for marshaling/unmarshaling. DO NOT EDIT.

package update

import (
	json "encoding/json"
	easyjson "github.com/mailru/easyjson"
	jlexer "github.com/mailru/easyjson/jlexer"
	jwriter "github.com/mailru/easyjson/jwriter"
)

// suppress unused package warning
var (
	_ *json.RawMessage
	_ *jlexer.Lexer
	_ *jwriter.Writer
	_ easyjson.Marshaler
)

func easyjsonDec4a999DecodeBiobtreeSrcUpdate(in *jlexer.Lexer, out *UniprotAttr) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "accessions":
			if in.IsNull() {
				in.Skip()
				out.Accession = nil
			} else {
				in.Delim('[')
				if out.Accession == nil {
					if !in.IsDelim(']') {
						out.Accession = make([]string, 0, 4)
					} else {
						out.Accession = []string{}
					}
				} else {
					out.Accession = (out.Accession)[:0]
				}
				for !in.IsDelim(']') {
					var v1 string
					v1 = string(in.String())
					out.Accession = append(out.Accession, v1)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "gene_name":
			if in.IsNull() {
				in.Skip()
				out.Gene = nil
			} else {
				in.Delim('[')
				if out.Gene == nil {
					if !in.IsDelim(']') {
						out.Gene = make([]string, 0, 4)
					} else {
						out.Gene = []string{}
					}
				} else {
					out.Gene = (out.Gene)[:0]
				}
				for !in.IsDelim(']') {
					var v2 string
					v2 = string(in.String())
					out.Gene = append(out.Gene, v2)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "name":
			if in.IsNull() {
				in.Skip()
				out.Name = nil
			} else {
				in.Delim('[')
				if out.Name == nil {
					if !in.IsDelim(']') {
						out.Name = make([]string, 0, 4)
					} else {
						out.Name = []string{}
					}
				} else {
					out.Name = (out.Name)[:0]
				}
				for !in.IsDelim(']') {
					var v3 string
					v3 = string(in.String())
					out.Name = append(out.Name, v3)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "alternative_name":
			if in.IsNull() {
				in.Skip()
				out.AltName = nil
			} else {
				in.Delim('[')
				if out.AltName == nil {
					if !in.IsDelim(']') {
						out.AltName = make([]string, 0, 4)
					} else {
						out.AltName = []string{}
					}
				} else {
					out.AltName = (out.AltName)[:0]
				}
				for !in.IsDelim(']') {
					var v4 string
					v4 = string(in.String())
					out.AltName = append(out.AltName, v4)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "submitted_name":
			if in.IsNull() {
				in.Skip()
				out.SubName = nil
			} else {
				in.Delim('[')
				if out.SubName == nil {
					if !in.IsDelim(']') {
						out.SubName = make([]string, 0, 4)
					} else {
						out.SubName = []string{}
					}
				} else {
					out.SubName = (out.SubName)[:0]
				}
				for !in.IsDelim(']') {
					var v5 string
					v5 = string(in.String())
					out.SubName = append(out.SubName, v5)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "features":
			if in.IsNull() {
				in.Skip()
				out.Features = nil
			} else {
				in.Delim('[')
				if out.Features == nil {
					if !in.IsDelim(']') {
						out.Features = make([]UniFeature, 0, 1)
					} else {
						out.Features = []UniFeature{}
					}
				} else {
					out.Features = (out.Features)[:0]
				}
				for !in.IsDelim(']') {
					var v6 UniFeature
					(v6).UnmarshalEasyJSON(in)
					out.Features = append(out.Features, v6)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "sequence":
			(out.Sequence).UnmarshalEasyJSON(in)
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonDec4a999EncodeBiobtreeSrcUpdate(out *jwriter.Writer, in UniprotAttr) {
	out.RawByte('{')
	first := true
	_ = first
	if len(in.Accession) != 0 {
		const prefix string = ",\"accessions\":"
		first = false
		out.RawString(prefix[1:])
		{
			out.RawByte('[')
			for v7, v8 := range in.Accession {
				if v7 > 0 {
					out.RawByte(',')
				}
				out.String(string(v8))
			}
			out.RawByte(']')
		}
	}
	if len(in.Gene) != 0 {
		const prefix string = ",\"gene_name\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		{
			out.RawByte('[')
			for v9, v10 := range in.Gene {
				if v9 > 0 {
					out.RawByte(',')
				}
				out.String(string(v10))
			}
			out.RawByte(']')
		}
	}
	if len(in.Name) != 0 {
		const prefix string = ",\"name\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		{
			out.RawByte('[')
			for v11, v12 := range in.Name {
				if v11 > 0 {
					out.RawByte(',')
				}
				out.String(string(v12))
			}
			out.RawByte(']')
		}
	}
	if len(in.AltName) != 0 {
		const prefix string = ",\"alternative_name\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		{
			out.RawByte('[')
			for v13, v14 := range in.AltName {
				if v13 > 0 {
					out.RawByte(',')
				}
				out.String(string(v14))
			}
			out.RawByte(']')
		}
	}
	if len(in.SubName) != 0 {
		const prefix string = ",\"submitted_name\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		{
			out.RawByte('[')
			for v15, v16 := range in.SubName {
				if v15 > 0 {
					out.RawByte(',')
				}
				out.String(string(v16))
			}
			out.RawByte(']')
		}
	}
	if len(in.Features) != 0 {
		const prefix string = ",\"features\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		{
			out.RawByte('[')
			for v17, v18 := range in.Features {
				if v17 > 0 {
					out.RawByte(',')
				}
				(v18).MarshalEasyJSON(out)
			}
			out.RawByte(']')
		}
	}
	if true {
		const prefix string = ",\"sequence\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		(in.Sequence).MarshalEasyJSON(out)
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v UniprotAttr) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonDec4a999EncodeBiobtreeSrcUpdate(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v UniprotAttr) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonDec4a999EncodeBiobtreeSrcUpdate(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *UniprotAttr) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonDec4a999DecodeBiobtreeSrcUpdate(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *UniprotAttr) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonDec4a999DecodeBiobtreeSrcUpdate(l, v)
}
func easyjsonDec4a999DecodeBiobtreeSrcUpdate1(in *jlexer.Lexer, out *UniSequence) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "sequence":
			out.Seq = string(in.String())
		case "length":
			out.Length = int(in.Int())
		case "mass":
			out.Mass = int(in.Int())
		case "checksum":
			out.Checksum = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonDec4a999EncodeBiobtreeSrcUpdate1(out *jwriter.Writer, in UniSequence) {
	out.RawByte('{')
	first := true
	_ = first
	if in.Seq != "" {
		const prefix string = ",\"sequence\":"
		first = false
		out.RawString(prefix[1:])
		out.String(string(in.Seq))
	}
	if in.Length != 0 {
		const prefix string = ",\"length\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int(int(in.Length))
	}
	if in.Mass != 0 {
		const prefix string = ",\"mass\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int(int(in.Mass))
	}
	if in.Checksum != "" {
		const prefix string = ",\"checksum\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Checksum))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v UniSequence) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonDec4a999EncodeBiobtreeSrcUpdate1(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v UniSequence) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonDec4a999EncodeBiobtreeSrcUpdate1(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *UniSequence) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonDec4a999DecodeBiobtreeSrcUpdate1(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *UniSequence) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonDec4a999DecodeBiobtreeSrcUpdate1(l, v)
}
func easyjsonDec4a999DecodeBiobtreeSrcUpdate2(in *jlexer.Lexer, out *UniLocation) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "begin":
			out.Begin = int(in.Int())
		case "end":
			out.End = int(in.Int())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonDec4a999EncodeBiobtreeSrcUpdate2(out *jwriter.Writer, in UniLocation) {
	out.RawByte('{')
	first := true
	_ = first
	if in.Begin != 0 {
		const prefix string = ",\"begin\":"
		first = false
		out.RawString(prefix[1:])
		out.Int(int(in.Begin))
	}
	if in.End != 0 {
		const prefix string = ",\"end\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int(int(in.End))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v UniLocation) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonDec4a999EncodeBiobtreeSrcUpdate2(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v UniLocation) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonDec4a999EncodeBiobtreeSrcUpdate2(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *UniLocation) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonDec4a999DecodeBiobtreeSrcUpdate2(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *UniLocation) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonDec4a999DecodeBiobtreeSrcUpdate2(l, v)
}
func easyjsonDec4a999DecodeBiobtreeSrcUpdate3(in *jlexer.Lexer, out *UniFeature) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "type":
			out.Type = string(in.String())
		case "description":
			out.Description = string(in.String())
		case "id":
			out.ID = string(in.String())
		case "evidences":
			if in.IsNull() {
				in.Skip()
				out.Evidences = nil
			} else {
				in.Delim('[')
				if out.Evidences == nil {
					if !in.IsDelim(']') {
						out.Evidences = make([]string, 0, 4)
					} else {
						out.Evidences = []string{}
					}
				} else {
					out.Evidences = (out.Evidences)[:0]
				}
				for !in.IsDelim(']') {
					var v19 string
					v19 = string(in.String())
					out.Evidences = append(out.Evidences, v19)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "original":
			out.Original = string(in.String())
		case "variatian":
			out.Variatian = string(in.String())
		case "location":
			(out.Loc).UnmarshalEasyJSON(in)
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonDec4a999EncodeBiobtreeSrcUpdate3(out *jwriter.Writer, in UniFeature) {
	out.RawByte('{')
	first := true
	_ = first
	if in.Type != "" {
		const prefix string = ",\"type\":"
		first = false
		out.RawString(prefix[1:])
		out.String(string(in.Type))
	}
	if in.Description != "" {
		const prefix string = ",\"description\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Description))
	}
	if in.ID != "" {
		const prefix string = ",\"id\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.ID))
	}
	if len(in.Evidences) != 0 {
		const prefix string = ",\"evidences\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		{
			out.RawByte('[')
			for v20, v21 := range in.Evidences {
				if v20 > 0 {
					out.RawByte(',')
				}
				out.String(string(v21))
			}
			out.RawByte(']')
		}
	}
	if in.Original != "" {
		const prefix string = ",\"original\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Original))
	}
	if in.Variatian != "" {
		const prefix string = ",\"variatian\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Variatian))
	}
	if true {
		const prefix string = ",\"location\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		(in.Loc).MarshalEasyJSON(out)
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v UniFeature) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonDec4a999EncodeBiobtreeSrcUpdate3(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v UniFeature) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonDec4a999EncodeBiobtreeSrcUpdate3(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *UniFeature) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonDec4a999DecodeBiobtreeSrcUpdate3(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *UniFeature) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonDec4a999DecodeBiobtreeSrcUpdate3(l, v)
}
func easyjsonDec4a999DecodeBiobtreeSrcUpdate4(in *jlexer.Lexer, out *TaxoAttr) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "name":
			out.Name = string(in.String())
		case "common_name":
			out.CommonName = string(in.String())
		case "rank":
			out.Rank = int(in.Int())
		case "taxonomic_division":
			out.TaxonomicDivision = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonDec4a999EncodeBiobtreeSrcUpdate4(out *jwriter.Writer, in TaxoAttr) {
	out.RawByte('{')
	first := true
	_ = first
	if in.Name != "" {
		const prefix string = ",\"name\":"
		first = false
		out.RawString(prefix[1:])
		out.String(string(in.Name))
	}
	if in.CommonName != "" {
		const prefix string = ",\"common_name\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.CommonName))
	}
	if in.Rank != 0 {
		const prefix string = ",\"rank\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int(int(in.Rank))
	}
	if in.TaxonomicDivision != "" {
		const prefix string = ",\"taxonomic_division\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.TaxonomicDivision))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v TaxoAttr) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonDec4a999EncodeBiobtreeSrcUpdate4(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v TaxoAttr) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonDec4a999EncodeBiobtreeSrcUpdate4(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *TaxoAttr) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonDec4a999DecodeBiobtreeSrcUpdate4(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *TaxoAttr) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonDec4a999DecodeBiobtreeSrcUpdate4(l, v)
}
func easyjsonDec4a999DecodeBiobtreeSrcUpdate5(in *jlexer.Lexer, out *InterproAtrr) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "short_name":
			out.ShortName = string(in.String())
		case "type":
			out.Type = string(in.String())
		case "protein_count":
			out.ProteinCount = int(in.Int())
		case "names":
			if in.IsNull() {
				in.Skip()
				out.Name = nil
			} else {
				in.Delim('[')
				if out.Name == nil {
					if !in.IsDelim(']') {
						out.Name = make([]string, 0, 4)
					} else {
						out.Name = []string{}
					}
				} else {
					out.Name = (out.Name)[:0]
				}
				for !in.IsDelim(']') {
					var v22 string
					v22 = string(in.String())
					out.Name = append(out.Name, v22)
					in.WantComma()
				}
				in.Delim(']')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonDec4a999EncodeBiobtreeSrcUpdate5(out *jwriter.Writer, in InterproAtrr) {
	out.RawByte('{')
	first := true
	_ = first
	if in.ShortName != "" {
		const prefix string = ",\"short_name\":"
		first = false
		out.RawString(prefix[1:])
		out.String(string(in.ShortName))
	}
	if in.Type != "" {
		const prefix string = ",\"type\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Type))
	}
	if in.ProteinCount != 0 {
		const prefix string = ",\"protein_count\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int(int(in.ProteinCount))
	}
	if len(in.Name) != 0 {
		const prefix string = ",\"names\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		{
			out.RawByte('[')
			for v23, v24 := range in.Name {
				if v23 > 0 {
					out.RawByte(',')
				}
				out.String(string(v24))
			}
			out.RawByte(']')
		}
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v InterproAtrr) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonDec4a999EncodeBiobtreeSrcUpdate5(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v InterproAtrr) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonDec4a999EncodeBiobtreeSrcUpdate5(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *InterproAtrr) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonDec4a999DecodeBiobtreeSrcUpdate5(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *InterproAtrr) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonDec4a999DecodeBiobtreeSrcUpdate5(l, v)
}
func easyjsonDec4a999DecodeBiobtreeSrcUpdate6(in *jlexer.Lexer, out *HgncAttr) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "symbols":
			if in.IsNull() {
				in.Skip()
				out.Symbol = nil
			} else {
				in.Delim('[')
				if out.Symbol == nil {
					if !in.IsDelim(']') {
						out.Symbol = make([]string, 0, 4)
					} else {
						out.Symbol = []string{}
					}
				} else {
					out.Symbol = (out.Symbol)[:0]
				}
				for !in.IsDelim(']') {
					var v25 string
					v25 = string(in.String())
					out.Symbol = append(out.Symbol, v25)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "names":
			if in.IsNull() {
				in.Skip()
				out.Name = nil
			} else {
				in.Delim('[')
				if out.Name == nil {
					if !in.IsDelim(']') {
						out.Name = make([]string, 0, 4)
					} else {
						out.Name = []string{}
					}
				} else {
					out.Name = (out.Name)[:0]
				}
				for !in.IsDelim(']') {
					var v26 string
					v26 = string(in.String())
					out.Name = append(out.Name, v26)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "locus_group":
			out.LocusGroup = string(in.String())
		case "location":
			out.Location = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonDec4a999EncodeBiobtreeSrcUpdate6(out *jwriter.Writer, in HgncAttr) {
	out.RawByte('{')
	first := true
	_ = first
	if len(in.Symbol) != 0 {
		const prefix string = ",\"symbols\":"
		first = false
		out.RawString(prefix[1:])
		{
			out.RawByte('[')
			for v27, v28 := range in.Symbol {
				if v27 > 0 {
					out.RawByte(',')
				}
				out.String(string(v28))
			}
			out.RawByte(']')
		}
	}
	if len(in.Name) != 0 {
		const prefix string = ",\"names\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		{
			out.RawByte('[')
			for v29, v30 := range in.Name {
				if v29 > 0 {
					out.RawByte(',')
				}
				out.String(string(v30))
			}
			out.RawByte(']')
		}
	}
	if in.LocusGroup != "" {
		const prefix string = ",\"locus_group\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.LocusGroup))
	}
	if in.Location != "" {
		const prefix string = ",\"location\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Location))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v HgncAttr) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonDec4a999EncodeBiobtreeSrcUpdate6(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v HgncAttr) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonDec4a999EncodeBiobtreeSrcUpdate6(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *HgncAttr) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonDec4a999DecodeBiobtreeSrcUpdate6(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *HgncAttr) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonDec4a999DecodeBiobtreeSrcUpdate6(l, v)
}
func easyjsonDec4a999DecodeBiobtreeSrcUpdate7(in *jlexer.Lexer, out *GoAttr) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "type":
			out.Type = string(in.String())
		case "label":
			out.Label = string(in.String())
		case "synonyms":
			if in.IsNull() {
				in.Skip()
				out.Synonyms = nil
			} else {
				in.Delim('[')
				if out.Synonyms == nil {
					if !in.IsDelim(']') {
						out.Synonyms = make([]string, 0, 4)
					} else {
						out.Synonyms = []string{}
					}
				} else {
					out.Synonyms = (out.Synonyms)[:0]
				}
				for !in.IsDelim(']') {
					var v31 string
					v31 = string(in.String())
					out.Synonyms = append(out.Synonyms, v31)
					in.WantComma()
				}
				in.Delim(']')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonDec4a999EncodeBiobtreeSrcUpdate7(out *jwriter.Writer, in GoAttr) {
	out.RawByte('{')
	first := true
	_ = first
	if in.Type != "" {
		const prefix string = ",\"type\":"
		first = false
		out.RawString(prefix[1:])
		out.String(string(in.Type))
	}
	if in.Label != "" {
		const prefix string = ",\"label\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Label))
	}
	if len(in.Synonyms) != 0 {
		const prefix string = ",\"synonyms\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		{
			out.RawByte('[')
			for v32, v33 := range in.Synonyms {
				if v32 > 0 {
					out.RawByte(',')
				}
				out.String(string(v33))
			}
			out.RawByte(']')
		}
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v GoAttr) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonDec4a999EncodeBiobtreeSrcUpdate7(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v GoAttr) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonDec4a999EncodeBiobtreeSrcUpdate7(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *GoAttr) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonDec4a999DecodeBiobtreeSrcUpdate7(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *GoAttr) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonDec4a999DecodeBiobtreeSrcUpdate7(l, v)
}
func easyjsonDec4a999DecodeBiobtreeSrcUpdate8(in *jlexer.Lexer, out *EnsemblAttr) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "name":
			out.Name = string(in.String())
		case "description":
			out.Description = string(in.String())
		case "start":
			out.Start = int(in.Int())
		case "end":
			out.End = int(in.Int())
		case "biotype":
			out.Biotype = string(in.String())
		case "genome":
			out.Genome = string(in.String())
		case "strand":
			out.Strand = string(in.String())
		case "seq_region_name":
			out.SeqRegionName = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonDec4a999EncodeBiobtreeSrcUpdate8(out *jwriter.Writer, in EnsemblAttr) {
	out.RawByte('{')
	first := true
	_ = first
	if in.Name != "" {
		const prefix string = ",\"name\":"
		first = false
		out.RawString(prefix[1:])
		out.String(string(in.Name))
	}
	if in.Description != "" {
		const prefix string = ",\"description\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Description))
	}
	if in.Start != 0 {
		const prefix string = ",\"start\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int(int(in.Start))
	}
	if in.End != 0 {
		const prefix string = ",\"end\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.Int(int(in.End))
	}
	if in.Biotype != "" {
		const prefix string = ",\"biotype\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Biotype))
	}
	if in.Genome != "" {
		const prefix string = ",\"genome\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Genome))
	}
	if in.Strand != "" {
		const prefix string = ",\"strand\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Strand))
	}
	if in.SeqRegionName != "" {
		const prefix string = ",\"seq_region_name\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.SeqRegionName))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v EnsemblAttr) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonDec4a999EncodeBiobtreeSrcUpdate8(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v EnsemblAttr) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonDec4a999EncodeBiobtreeSrcUpdate8(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *EnsemblAttr) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonDec4a999DecodeBiobtreeSrcUpdate8(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *EnsemblAttr) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonDec4a999DecodeBiobtreeSrcUpdate8(l, v)
}
func easyjsonDec4a999DecodeBiobtreeSrcUpdate9(in *jlexer.Lexer, out *CommonAttr) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "name":
			out.Name = string(in.String())
		case "disease_name":
			out.DiseaseName = string(in.String())
		case "pathway_name":
			out.PathwayName = string(in.String())
		case "type":
			out.Type = string(in.String())
		case "molecule_type":
			out.MoleculeType = string(in.String())
		case "method":
			out.Method = string(in.String())
		case "chains":
			out.Chains = string(in.String())
		case "resoultion":
			out.Resuloution = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonDec4a999EncodeBiobtreeSrcUpdate9(out *jwriter.Writer, in CommonAttr) {
	out.RawByte('{')
	first := true
	_ = first
	if in.Name != "" {
		const prefix string = ",\"name\":"
		first = false
		out.RawString(prefix[1:])
		out.String(string(in.Name))
	}
	if in.DiseaseName != "" {
		const prefix string = ",\"disease_name\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.DiseaseName))
	}
	if in.PathwayName != "" {
		const prefix string = ",\"pathway_name\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.PathwayName))
	}
	if in.Type != "" {
		const prefix string = ",\"type\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Type))
	}
	if in.MoleculeType != "" {
		const prefix string = ",\"molecule_type\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.MoleculeType))
	}
	if in.Method != "" {
		const prefix string = ",\"method\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Method))
	}
	if in.Chains != "" {
		const prefix string = ",\"chains\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Chains))
	}
	if in.Resuloution != "" {
		const prefix string = ",\"resoultion\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Resuloution))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v CommonAttr) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonDec4a999EncodeBiobtreeSrcUpdate9(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v CommonAttr) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonDec4a999EncodeBiobtreeSrcUpdate9(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *CommonAttr) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonDec4a999DecodeBiobtreeSrcUpdate9(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *CommonAttr) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonDec4a999DecodeBiobtreeSrcUpdate9(l, v)
}
